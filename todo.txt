
ADD pytest presetup hook!

RELEASE 0.6 TO PYPI AND ADVERTIZE ON ML

Always use check-manifest before upload

Replace emit_warnings by standard warnings.warn() from deprecation.py




        ### "__dcp_injected__"
        #### if get_patcher_setting('DCP_PATCH_INJECTED_OBJECTS'):
            #print("PATCHING injected object", object_to_patch)



        If `fixer_delayed`is True, the fixer is only applied after django.setup() has been called
        (eg. so that ORM models are available for introspection and patching).



        assert fixer_delayed in (True, False), fixer_delayed



        fixer_family = "django" + fixer_reference_version  # eg. django1.9





from django_compat_patcher.utilities import tuplify_software_version
from django_compat_patcher import utilities


        ALL = "*"  # special value for patcher settings
        include_fixer_ids = utilities.get_patcher_setting("DCP_INCLUDE_FIXER_IDS", settings=settings)
        include_fixer_families = utilities.get_patcher_setting("DCP_INCLUDE_FIXER_FAMILIES", settings=settings)
        exclude_fixer_ids = utilities.get_patcher_setting("DCP_EXCLUDE_FIXER_IDS", settings=settings)
        exclude_fixer_families = utilities.get_patcher_setting("DCP_EXCLUDE_FIXER_FAMILIES", settings=settings)



        utilities.apply_runtime_settings(settings)  # called even if settings are empty



        A settings dict/objects can be provided, to REPLACE lookups in Django settings.




def apply_runtime_settings(settings):
    """
    Change at runtime the logging/warnings settings.
    """
    global DCP_ENABLE_WARNINGS, DCP_LOGGING_LEVEL, _initial_setup_done

    settings = settings or {}

    if not _initial_setup_done:
        DCP_ENABLE_WARNINGS = get_patcher_setting("DCP_ENABLE_WARNINGS")
        DCP_LOGGING_LEVEL = get_patcher_setting("DCP_LOGGING_LEVEL")
        _initial_setup_done = True

    if "DCP_ENABLE_WARNINGS" in settings:
        dcp_enable_warnings = settings["DCP_ENABLE_WARNINGS"]
        assert dcp_enable_warnings in (True, False), dcp_enable_warnings
        DCP_ENABLE_WARNINGS = dcp_enable_warnings  # runtime switch on/off

    if "DCP_LOGGING_LEVEL" in settings:
        dcp_logging_level = settings["DCP_LOGGING_LEVEL"]
        assert dcp_logging_level is None or hasattr(logging, dcp_logging_level), dcp_logging_level
        DCP_LOGGING_LEVEL = dcp_logging_level



min_logging_level="INFO", enable_warnings=True, patch_injected_objects="__compat_patcher_injected__"


        settings = dict(min_logging_level=min_logging_level,
                        enable_warnings=enable_warnings,
                        patch_injected_objects=patch_injected_objects)


# for lazy setup of the some settings
_initial_setup_done = False

# global on/off switch for (deprecation) warnings, to be modified by patch() if wanted
DCP_ENABLE_WARNINGS = False

# global logging level string, or None if no logging
DCP_LOGGING_LEVEL = None



        # Micromanaging, because a validation Schema is overkill for now
        if name == "DCP_LOGGING_LEVEL":
            assert setting is None or hasattr(logging, setting), repr(setting)
        elif name in ("DCP_PATCH_INJECTED_OBJECTS", "DCP_ENABLE_WARNINGS"):
            assert isinstance(setting, bool), repr(setting)
        else:
            assert (setting == "*" or
                    (isinstance(setting, list) and all(isinstance(f, six.string_types) for f in setting))), setting


        Fetches the value of the DCP setting.

        If it's not found, a default value is returned for the setting.

        If provided, the 'settings' arguments is a dict which *completely*
        replaces django settings (no fallback occurs).

        :param name: The name of the setting
        :param settings: Possible replacement for the project's settings
        :return: The value of the setting "name


                # Micromanaging, because a validation Schema is overkill for now
                if name in ("logging_level", "enable_warnings", "patch_injected_objects"):
                    pass  # Let utilities module validated them
                    assert setting is None or hasattr(logging, setting), repr(setting)
                elif name in ("DCP_PATCH_INJECTED_OBJECTS", "DCP_ENABLE_WARNINGS"):
                    assert isinstance(setting, bool), repr(setting)
                else:
                    assert (setting == "*" or
                            (isinstance(setting, list) and all(isinstance(f, six.string_types) for f in setting))), setting
